//
// StatementExecutor.cpp
//
// $Id: //poco/1.3/Data/PostgreSQL/src/StatementExecutor.cpp#1 $
//
// Library: Data
// Package: PostgreSQL
// Module:  StatementExecutor
//
// Copyright (c) 2008, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Data/PostgreSQL/StatementExecutor.h"
#include "Poco/Data/PostgreSQL/PostgreSQLTypes.h"

#include "Poco/Format.h"
#include "Poco/UUID.h"
#include "Poco/UUIDGenerator.h"
#include "Poco/NumberParser.h"

#include <regex>

namespace
{
	std::size_t countOfPlaceHoldersInSQLStatement( const std::string & aSQLStatement )
	{
        std::regex const expression( "[$][0-9]+" );  // match literal dollar signs followed directly by one or more digits
        
        std::ptrdiff_t const match_count(std::distance(
                                                        std::sregex_iterator( aSQLStatement.begin(), aSQLStatement.end(), expression ),
                                                        std::sregex_iterator() ) );
        return match_count;
	}
}

namespace Poco {
namespace Data {
namespace PostgreSQL {


StatementExecutor::StatementExecutor( SessionHandle & aSessionHandle )
	: _sessionHandle                   ( aSessionHandle ),
      _state                           ( STMT_INITED ),
      _pResultHandle                   ( 0 ),
      _countPlaceholdersInSQLStatement ( 0 ),
      _currentRow                      ( -1 ),
      _affectedRowCount                ( 0 )
{
}


StatementExecutor::~StatementExecutor()
{
    try
    {
        PQResultClear resultClearer( _pResultHandle );
    }
    catch (...)
    {
    }
}


StatementExecutor::State
StatementExecutor::state() const
{
	return _state;
}

void StatementExecutor::prepare( const std::string & aSQLStatement )
{
    if ( ! _sessionHandle.isConnected() )
    {
		throw NotConnectedException();
    }
	
    if ( _state >= STMT_COMPILED )
	{
		_state = STMT_COMPILED;
		return;
	}

    // prepare parameters for the call to PQprepare
    const char* ptrCSQLStatement = aSQLStatement.c_str();
    std::size_t countPlaceholdersInSQLStatement = countOfPlaceHoldersInSQLStatement( aSQLStatement );

    Poco::UUIDGenerator & generator = Poco::UUIDGenerator::defaultGenerator();
    Poco::UUID uuid( generator.create() ); // time based
    std::string statementName = uuid.toString();
    const char* pStatementName = statementName.c_str();
    
    // clear out the meta data.  One way or another it is now obsolete.
    _resultColumns.clear();
    // clear out any result data.  One way or another it is now obsolete.
    _outputParameterVector.clear();

    PGresult * ptrPGResult = 0;
    
    {
        // lock the session
        Poco::FastMutex::ScopedLock mutexLocker( _sessionHandle.mutex() );
    
        // prepare the statement - temporary PGresult returned
        ptrPGResult = PQprepare( _sessionHandle,
                                 pStatementName,
                                 ptrCSQLStatement,
                                 countPlaceholdersInSQLStatement,
                                 0  // not specifying type Oids
                                );

    }
    
    {
        // setup to clear the result from PQprepare
        PQResultClear resultClearer( ptrPGResult );

        if ( ! ptrPGResult  ||
             PQresultStatus( ptrPGResult ) != PGRES_COMMAND_OK )
        {
            throw StatementException( std::string( "postgresql_stmt_prepare error: " ) + PQresultErrorMessage ( ptrPGResult ) + " " + aSQLStatement );
        }

    }

    // Determine what the structure of a statement result will look like
        
    {
        // lock the session
        Poco::FastMutex::ScopedLock mutexLocker( _sessionHandle.mutex() );

        ptrPGResult = PQdescribePrepared( _sessionHandle, pStatementName );
    }
    
    {
        PQResultClear resultClearer( ptrPGResult );
    
        {
            if ( ! ptrPGResult  ||
                 PQresultStatus( ptrPGResult ) != PGRES_COMMAND_OK )
            {
                throw StatementException( std::string( "postgresql_stmt_describe error: " ) + PQresultErrorMessage ( ptrPGResult ) + " " + aSQLStatement );
            }
        }
    
        // remember the structure of the statement result
    
        int fieldCount = PQnfields( ptrPGResult );
        if ( fieldCount < 0 )
        {
            fieldCount = 0;
        }
    
        for ( int i = 0; i < fieldCount; ++i )
        {
            _resultColumns.push_back(
                               MetaColumn( i,                                   // position
                                           PQfname( ptrPGResult, i ),           // name
                                           Poco::Data::MetaColumn::FDT_UNKNOWN, // type - TODO: Map from OIDS to Metacolumn types
                                           0,                                   // length
                                           PQfmod( ptrPGResult, i ),            // precision
                                           true                                 // nullable? - no easy way to tell, so assume yes
                                         )
                              );
        
        }
        
        // setup a vector for the results
        _outputParameterVector.resize( fieldCount );
    }
   
	_SQLStatement                    = aSQLStatement;
    _preparedStatementName           = statementName;
	_countPlaceholdersInSQLStatement = countPlaceholdersInSQLStatement;
    
    _state                           = STMT_COMPILED;  // must be last
    
}


void StatementExecutor::bindParams( const InputParameterVector & anInputParameterVector )
{
    if ( ! _sessionHandle.isConnected() )
    {
		throw NotConnectedException();
    }

	if ( _state < STMT_COMPILED )
    {
		throw StatementException( "Statement is not compiled yet" );
    }

	if ( anInputParameterVector.size() != _countPlaceholdersInSQLStatement )
    {
		throw StatementException( std::string( "incorrect bind parameters count for SQL Statement: " ) + _SQLStatement );
    }

    // Just record the input vector for later execution
    _inputParameterVector = anInputParameterVector;
}

void StatementExecutor::execute()
{
    if ( ! _sessionHandle.isConnected() )
    {
		throw NotConnectedException();
    }
	
    if ( _state < STMT_COMPILED )
    {
		throw StatementException( "Statement is not compiled yet" );
    }
    
    if (    _countPlaceholdersInSQLStatement != 0
         && _inputParameterVector.size() != _countPlaceholdersInSQLStatement )
    {
		throw StatementException( "Count of Parameters in Statement different than supplied parameters" );
    }

    // "transmogrify" the _inputParameterVector to the C format required by PQexecPrepared
    
   /* - from example
    const char *paramValues[1];
    int         paramLengths[1];
    int         paramFormats[1];
   */
    
    std::vector< const char * > pParameterVector;
    std::vector< int >  parameterLengthVector;
    std::vector< int >  parameterFormatVector;
    
    InputParameterVector::const_iterator cItr    = _inputParameterVector.begin();
    InputParameterVector::const_iterator cItrEnd = _inputParameterVector.end();
    
    for (; cItr != cItrEnd; ++cItr)
    {
        try
        {
            pParameterVector.push_back      ( static_cast< const char * >( cItr->pInternalRepresentation() ) );
            parameterLengthVector.push_back( cItr->size() );
            parameterFormatVector.push_back( cItr->isBinary() ? 1 : 0 );
        }
        catch ( std::bad_alloc& )
        {
            throw StatementException( "Memory Allocation Error" );
        }
    }
    
    PGresult * ptrPGResult = 0;
   
    {
        Poco::FastMutex::ScopedLock mutexLocker( _sessionHandle.mutex() );
        
/* - from api doc
        PGresult *PQexecPrepared(PGconn *conn,
                                 const char *stmtName,
                                 int nParams,
                                 const char * const *paramValues,
                                 const int *paramLengths,
                                 const int *paramFormats,
                                 int resultFormat);
*/
        ptrPGResult = PQexecPrepared ( _sessionHandle,
                                       _preparedStatementName.c_str(),
                                       _countPlaceholdersInSQLStatement,
                                       _inputParameterVector.size() != 0 ? &pParameterVector[ 0 ]      : 0,
                                       _inputParameterVector.size() != 0 ? &parameterLengthVector[ 0 ] : 0,
                                       _inputParameterVector.size() != 0 ? &parameterFormatVector[ 0 ] : 0,
                                       0 // text based result please
                                      );

    }
    
    // Don't setup to auto clear the result.  It is required to retrieve the results later.

	if (    ! ptrPGResult
         || (    PQresultStatus( ptrPGResult ) != PGRES_COMMAND_OK
              && PQresultStatus( ptrPGResult ) != PGRES_TUPLES_OK )
       )
    {
        PQResultClear resultClearer( ptrPGResult );
        
        const char* pSeverity   = PQresultErrorField( ptrPGResult, PG_DIAG_SEVERITY );
        const char* pSQLState   = PQresultErrorField( ptrPGResult, PG_DIAG_SQLSTATE );
        const char* pDetail     = PQresultErrorField( ptrPGResult, PG_DIAG_MESSAGE_DETAIL );
        const char* pHint       = PQresultErrorField( ptrPGResult, PG_DIAG_MESSAGE_HINT );
        const char* pConstraint = PQresultErrorField( ptrPGResult, PG_DIAG_CONSTRAINT_NAME );

		throw StatementException(   std::string( "postgresql_stmt_execute error: " )
                                  + PQresultErrorMessage ( ptrPGResult )
                                  + " Severity: "
                                  + (pSeverity   ? pSeverity   : "N/A")
                                  + " State: "
                                  + (pSQLState   ? pSQLState   : "N/A")
                                  + " Detail: "
                                  + (pDetail     ? pDetail     : "N/A")
                                  + " Hint: "
                                  + (pHint       ? pHint       : "N/A")
                                  + " Constraint: "
                                  + (pConstraint ? pConstraint : "N/A")
                                );
    }

    // clear out any old result first
    {
        PQResultClear resultClearer( _pResultHandle );
    }
    
    _pResultHandle = ptrPGResult;

    // are there any results?
    int affectedRowCount = 0;
    
    if ( PGRES_TUPLES_OK == PQresultStatus( _pResultHandle ) )
    {
         affectedRowCount = PQntuples( _pResultHandle );
        
        if ( affectedRowCount > 0 )
        {
            _currentRow = 0;
        }
        
        if ( _affectedRowCount != affectedRowCount )
        {
            _affectedRowCount = affectedRowCount;
        }
    }
    else
    {   // non Select DML statments also have an affected row count
        // unfortunately postgres offers up this count as a char * - go figure!
        const char * pNonSelectAffectedRowCountString = PQcmdTuples( _pResultHandle );
        if ( 0 != pNonSelectAffectedRowCountString )
        {
            if (    Poco::NumberParser::tryParse( pNonSelectAffectedRowCountString, affectedRowCount )
                 && _affectedRowCount != affectedRowCount
               )
            {
                _affectedRowCount = affectedRowCount;
                _currentRow = _affectedRowCount;  // no fetching on these statements
            }
        }
    }

	_state = STMT_EXECUTED;
}


bool
StatementExecutor::fetch()
{
    if ( ! _sessionHandle.isConnected() )
    {
		throw NotConnectedException();
    }
	
    if ( _state < STMT_EXECUTED )
    {
		throw StatementException( "Statement is not yet executed" );
    }
    
	if ( 0 == _outputParameterVector.size() )
    {
		throw StatementException( "No output location for Statement" );
    }
    
    if ( _currentRow == getAffectedRowCount() )  // already retrieved last row?
    {
        return false;
    }
    
    std::size_t countColumns = columnsReturned();

    if (    0 == countColumns
         || PGRES_TUPLES_OK != PQresultStatus( _pResultHandle ) )
    {
        return false;
    }
    
    for ( std::size_t i = 0; i < countColumns; ++i )
    {
        _outputParameterVector.at( i ).setValues( POSTGRESQL_TYPE_NONE,                                             // TODO - set based on Oid
                                                  PQftype( _pResultHandle, i ),                                     // Oid of column
                                                  _currentRow,                                                      // the row number of the result
                                                  PQgetvalue( _pResultHandle, _currentRow, i ),                     // a pointer to the data
                                                  PQgetlength( _pResultHandle, _currentRow, i ),                    // the length of the data returned
                                                  PQgetisnull( _pResultHandle, _currentRow, i ) == 1 ? true : false // is the column null
                                                );
    }
    
    // advance to next row
    ++_currentRow;
    
    return true;
}


std::size_t
StatementExecutor::getAffectedRowCount() const
{
	return _affectedRowCount;
}

std::size_t
StatementExecutor::columnsReturned() const
{
    return static_cast< std::size_t > ( _resultColumns.size() );
}

const MetaColumn&
StatementExecutor::metaColumn( std::size_t aPosition ) const
{
	if ( aPosition >= columnsReturned() )
    {
		throw StatementException( "Invalid column number for metaColumn" );
    }

	return _resultColumns.at( aPosition );
}

const OutputParameter&
StatementExecutor::resultColumn( std::size_t aPosition ) const
{
	if ( aPosition >= columnsReturned() )
    {
		throw StatementException( "Invalid column number for resultColumn" );
    }
    
	return _outputParameterVector.at( aPosition );
}

}}}
