//
// SocketIOChannelTest.cpp
//
// $Id: //poco/Main/template/test.cpp#6 $
//
// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "SocketIOChannelTest.h"
#include "UDPEchoServer.h"
#include "CppUnit/TestCaller.h"
#include "CppUnit/TestSuite.h"
#include "Poco/Types.h"
#include "Poco/Format.h"
#include "Poco/ActiveResult.h"
#include "Poco/IOChannel.h"
#include "Poco/IOChannelConfig.h"
#include "Poco/Net/SocketIOChannel.h"
#include "Poco/ActiveIOChannel.h"
#include "Poco/Net/TCPServer.h"
#include "Poco/Net/TCPServerConnection.h"
#include "Poco/Net/TCPServerConnectionFactory.h"
#include "Poco/Net/TCPServerParams.h"
#include "Poco/Net/ServerSocket.h"
#include "Poco/Net/StreamSocket.h"
#include "Poco/Void.h"
#include "Poco/Types.h"
#include "Poco/Thread.h"
#include "Poco/BinaryReader.h"
#include "Poco/BinaryWriter.h"
#include <iostream>


using Poco::UInt32;
using Poco::Int64;
using Poco::UInt64;
using Poco::ActiveResult;
using Poco::Void;
using Poco::Thread;
using Poco::format;
using Poco::BinaryReader;
using Poco::BinaryWriter;
using Poco::IOChannel;
using Poco::ActiveIOChannel;
using Poco::IOChannelInputStream;
using Poco::IOChannelOutputStream;
using Poco::IOChannelConfig;
using Poco::Net::SocketIOChannel;
using Poco::Net::TCPServer;
using Poco::Net::TCPServerConnection;
using Poco::Net::TCPServerConnectionFactory;
using Poco::Net::TCPServerConnectionFactoryImpl;
using Poco::Net::TCPServerParams;
using Poco::Net::ServerSocket;
using Poco::Net::StreamSocket;


namespace
{
	class EchoConnection: public TCPServerConnection
	{
	public:
		EchoConnection(const StreamSocket& s): TCPServerConnection(s)
		{
		}
		
		void run()
		{
			StreamSocket& ss = socket();
			try
			{
				char buffer[256];
				int n = ss.receiveBytes(buffer, sizeof(buffer));
				while (n > 0)
				{
					ss.sendBytes(buffer, n);
					n = ss.receiveBytes(buffer, sizeof(buffer));
				}
			}
			catch (Poco::Exception& exc)
			{
				std::cerr << "EchoConnection: " << exc.displayText() << std::endl;
			}
		}
	};
}


SocketIOChannelTest::SocketIOChannelTest(const std::string& name): 
	CppUnit::TestCase(name)
{
}


SocketIOChannelTest::~SocketIOChannelTest()
{
}


void SocketIOChannelTest::testChannelStream()
{
	ServerSocket svs(0);
	TCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);
	srv.start();
	assert (srv.currentConnections() == 0);
	assert (srv.currentThreads() == 0);
	assert (srv.queuedConnections() == 0);
	assert (srv.totalConnections() == 0);
	
	SocketIOChannel network(new IOChannelConfig(format("localhost:%hu", svs.address().port()),
		IOChannelConfig::CONNECTION_CHANNEL,
		1000));
	
	std::string data("hello, world");
	network.write(data.data(), (int) data.size());
	char buffer[256];
	int n = network.read(buffer, sizeof(buffer));
	assert ((int) data.size() == n);
	assert (std::string(buffer, n) == data);
	assert (srv.currentConnections() == 1);
	assert (srv.currentThreads() == 1);
	assert (srv.queuedConnections() == 0);
	assert (srv.totalConnections() == 1);
	network.close();
	Thread::sleep(300);
	assert (srv.currentConnections() == 0);
}


void SocketIOChannelTest::testActiveChannelStream()
{
	ServerSocket svs(0);
	TCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);
	srv.start();

	SocketIOChannel network(new IOChannelConfig(format("localhost:%hu", svs.address().port()),
		IOChannelConfig::CONNECTION_CHANNEL,
		1000));

	std::string str1 = "1234567890";
	std::string str2 = "";
	
	ActiveIOChannel<SocketIOChannel> activeChannel(network);
	ActiveResult<int> result1 = activeChannel.write(str1);
	result1.wait();
	ActiveResult<std::string> result2 = activeChannel.read(0);
	result2.wait();
	assert("1234567890" == result2.data());
}


void SocketIOChannelTest::testStreamsStream()
{
	ServerSocket svs(0);
	TCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);
	srv.start();

	SocketIOChannel net(new IOChannelConfig(format("localhost:%hu", svs.address().port()),
		IOChannelConfig::CONNECTION_CHANNEL,
		1000));

	IOChannelOutputStream sos(net);
	IOChannelInputStream sis(net);

	sos << "1234567890\n";
	std::string str;
	sis >> str;
	assert("1234567890" == str);

	sos << 1.5;
	sos << "\n";
	sis >> str;
	assert("1.5" == str);
}


void SocketIOChannelTest::testBinaryStream()
{
	ServerSocket svs(0);
	TCPServer srv(new TCPServerConnectionFactoryImpl<EchoConnection>(), svs);
	srv.start();

	SocketIOChannel net(new IOChannelConfig(format("localhost:%hu", svs.address().port()),
		IOChannelConfig::CONNECTION_CHANNEL,
		1000));

	IOChannelOutputStream sos(net);
	IOChannelInputStream sis(net);

	BinaryWriter bw(sos);
	BinaryReader br(sis);

	writeBinary(bw);
	readBinary(br);
}


void SocketIOChannelTest::testChannelDatagram()
{
	UDPEchoServer echoServer;
	
	SocketIOChannel network(new IOChannelConfig(format("localhost:%hu", echoServer.address().port()),
		IOChannelConfig::CONNECTIONLESS_CHANNEL,
		1000));

	std::string data("hello, world");
	network.write(data.data(), (int) data.size());
	char buffer[256];
	int n = network.read(buffer, sizeof(buffer));
	assert (n > 0);
	assert (std::string(buffer, n) == data);
}


void SocketIOChannelTest::testActiveChannelDatagram()
{
	UDPEchoServer echoServer;
	
	SocketIOChannel network(new IOChannelConfig(format("localhost:%hu", echoServer.address().port()),
		IOChannelConfig::CONNECTIONLESS_CHANNEL,
		1000));

	std::string str1 = "1234567890";
	std::string str2 = "";
	
	ActiveIOChannel<SocketIOChannel> activeChannel(network);
	ActiveResult<int> result1 = activeChannel.write(str1);
	result1.wait();
	ActiveResult<std::string> result2 = activeChannel.read(0);
	result2.wait();
	assert("1234567890" == result2.data());
}


void SocketIOChannelTest::testStreamsDatagram()
{
	UDPEchoServer echoServer;
	
	SocketIOChannel net(new IOChannelConfig(format("localhost:%hu", echoServer.address().port()),
		IOChannelConfig::CONNECTIONLESS_CHANNEL,
		1000));

	IOChannelOutputStream sos(net);
	IOChannelInputStream sis(net);

	sos << "1234567890\n";
	std::string str;
	sis >> str;
	assert("1234567890" == str);

	sos << 1.5;
	sos << "\n";
	sis >> str;
	assert("1.5" == str);
}


void SocketIOChannelTest::testBinaryDatagram()
{
	UDPEchoServer echoServer;
	
	SocketIOChannel net(new IOChannelConfig(format("localhost:%hu", echoServer.address().port()),
		IOChannelConfig::CONNECTIONLESS_CHANNEL,
		1000));

	IOChannelOutputStream sos(net);
	IOChannelInputStream sis(net);

	BinaryWriter bw(sos);
	BinaryReader br(sis);

	writeBinary(bw);
	readBinary(br);
}


void SocketIOChannelTest::writeBinary(BinaryWriter& writer)
{
	writer << true;
	writer << false;
	writer << 'a';

	writer << (short) -100;
	writer << (unsigned short) 50000;
	writer << -123456;
	writer << (unsigned) 123456;
	writer << (long) -1234567890;
	writer << (unsigned long) 1234567890;
	
#if defined(POCO_HAVE_INT64)
	writer << (Int64) -1234567890;
	writer << (UInt64) 1234567890;
#endif

	writer << (float) 1.5;
	writer << (double) -1.5;
	
	writer << "foo";
	writer << "";

	writer << std::string("bar");
	writer << std::string();
	
	writer.write7BitEncoded((UInt32) 100);
	writer.write7BitEncoded((UInt32) 1000);
	writer.write7BitEncoded((UInt32) 10000);
	writer.write7BitEncoded((UInt32) 100000);
	writer.write7BitEncoded((UInt32) 1000000);

#if defined(POCO_HAVE_INT64)
	writer.write7BitEncoded((UInt64) 100);
	writer.write7BitEncoded((UInt64) 1000);
	writer.write7BitEncoded((UInt64) 10000);
	writer.write7BitEncoded((UInt64) 100000);
	writer.write7BitEncoded((UInt64) 1000000);
#endif

	writer.writeRaw("RAW");
}


void SocketIOChannelTest::readBinary(BinaryReader& reader)
{
	bool b = false;
	reader >> b;
	assert (b);
	reader >> b;
	assert (!b);
	
	char c = ' ';
	reader >> c;
	assert (c == 'a');

	short shortv = 0;
	reader >> shortv;
	assert (shortv == -100);

	unsigned short ushortv = 0;
	reader >> ushortv;
	assert (ushortv == 50000);

	int intv = 0;
	reader >> intv;
	assert (intv == -123456);

	unsigned uintv = 0;
	reader >> uintv;
	assert (uintv == 123456);

	long longv = 0;
	reader >> longv;
	assert (longv == -1234567890);

	unsigned long ulongv = 0;
	reader >> ulongv;
	assert (ulongv == 1234567890);

#if defined(POCO_HAVE_INT64)
	Int64 int64v = 0;
	reader >> int64v;
	assert (int64v == -1234567890);
	
	UInt64 uint64v = 0;
	reader >> uint64v;
	assert (uint64v == 1234567890);
#endif

	float floatv = 0.0;
	reader >> floatv;
	assert (floatv == 1.5);
	
	double doublev = 0.0;
	reader >> doublev;
	assert (doublev == -1.5);

	std::string str;
	reader >> str;
	assert (str == "foo");
	reader >> str;
	assert (str == "");
	
	reader >> str;
	assert (str == "bar");
	reader >> str;
	assert (str == "");

	UInt32 uint32v;
	reader.read7BitEncoded(uint32v);
	assert (uint32v == 100);
	reader.read7BitEncoded(uint32v);
	assert (uint32v == 1000);
	reader.read7BitEncoded(uint32v);
	assert (uint32v == 10000);
	reader.read7BitEncoded(uint32v);
	assert (uint32v == 100000);
	reader.read7BitEncoded(uint32v);
	assert (uint32v == 1000000);

#if defined(POCO_HAVE_INT64)
	reader.read7BitEncoded(uint64v);
	assert (uint64v == 100);
	reader.read7BitEncoded(uint64v);
	assert (uint64v == 1000);
	reader.read7BitEncoded(uint64v);
	assert (uint64v == 10000);
	reader.read7BitEncoded(uint64v);
	assert (uint64v == 100000);
	reader.read7BitEncoded(uint64v);
	assert (uint64v == 1000000);
#endif

	reader.readRaw(3, str);
	assert (str == "RAW");
}


void SocketIOChannelTest::setUp()
{
}


void SocketIOChannelTest::tearDown()
{
}


CppUnit::Test* SocketIOChannelTest::suite()
{
	CppUnit::TestSuite* pSuite = new CppUnit::TestSuite("SocketIOChannelTest");

	CppUnit_addTest(pSuite, SocketIOChannelTest, testChannelStream);
	CppUnit_addTest(pSuite, SocketIOChannelTest, testActiveChannelStream);
	CppUnit_addTest(pSuite, SocketIOChannelTest, testStreamsStream);
	CppUnit_addTest(pSuite, SocketIOChannelTest, testBinaryStream);
	CppUnit_addTest(pSuite, SocketIOChannelTest, testChannelDatagram);
	CppUnit_addTest(pSuite, SocketIOChannelTest, testActiveChannelDatagram);
	CppUnit_addTest(pSuite, SocketIOChannelTest, testStreamsDatagram);
	CppUnit_addTest(pSuite, SocketIOChannelTest, testBinaryDatagram);

	return pSuite;
}
