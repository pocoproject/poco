//
// ifconfig.cpp
//
// $Id: //poco/1.4/Net/samples/download/src/ifconfig.cpp#1 $
//
// This sample demonstrates the (display only) ifconfig-like capabilities 
// of the NetworkInterface class.
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Path.h"
#include "Poco/Exception.h"
#include "Poco/Net/IPAddress.h"
#include "Poco/Net/NetworkInterface.h"
#include <memory>
#include <iostream>


using Poco::Path;
using Poco::Exception;
using Poco::Net::IPAddress;
using Poco::Net::NetworkInterface;


int main(int argc, char** argv)
{

	if (argc != 1)
	{
		Path p(argv[0]);
		std::cerr << "usage: " << p.getBaseName() << std::endl;
		return 1;
	}

	try
	{
		const NetworkInterface::Map map = NetworkInterface::map();
		for ( NetworkInterface::Map::const_iterator it = map.begin();
		it != map.end(); ++it)
		{
			const NetworkInterface& intf = it->second;
			std::string sep("");
			std::cout << intf.name() << " [" << intf.index() << "]: ";
			std::cout << "<";
			if (intf.isUp())
			{
				std::cout << sep << "UP";
				sep = ",";
			}

			if (intf.isRunning())
			{
				std::cout << sep << "RUNNING";
				sep = ",";
			}

			if (intf.isLoopback())
			{
				std::cout << sep << "LOOPBACK";
				sep = ",";
			}

			if (intf.isPointToPoint())
			{
				std::cout << sep << "P2P";
				sep = ",";
			}
			
			if (intf.supportsIPv4())
			{
				std::cout << sep << "IPv4";
				sep = ",";
			}

			if (intf.supportsIPv6())
			{
				std::cout << sep << "IPv6";
				sep = ",";
			}

			if (intf.supportsBroadcast())
			{
				std::cout << sep << "BCAST";
				sep = ",";
			}

			if (intf.supportsMulticast())
			{
				std::cout << sep << "MCAST";
				sep = ",";
			}

			if (!intf.isLoopback())
			{
				std::cout << sep << std::dec << intf.mtu();
				sep = ",";
			}

			std::cout << ">" << std::endl;

			const NetworkInterface::AddressList& ipList = intf.addressList();

			NetworkInterface::AddressList::const_iterator ipIt = ipList.begin();
			NetworkInterface::AddressList::const_iterator ipEnd = ipList.end();
			for (; ipIt != ipEnd; ++ipIt)
			{
				std::cout << "  " << ipIt->get<NetworkInterface::IP_ADDRESS>().toString();
				IPAddress addr;
				addr = ipIt->get<NetworkInterface::SUBNET_MASK>();
				if (!addr.isWildcard()) std::cout << '/' << addr.toString() << " (" << addr.prefixLength() << ')';
				addr = ipIt->get<NetworkInterface::BROADCAST_ADDRESS>();
				if (!addr.isWildcard()) std::cout << (intf.isPointToPoint() ? "  dest  " : "  bcast  ") << addr.toString();
				std::cout << std::endl;
			}
			std::cout << std::endl;
		}
	}
	catch (Exception& exc)
	{
		std::cerr << exc.displayText() << std::endl;
		return 1;
	}
	
	return 0;
}
