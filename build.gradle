plugins {
	id 'c'
	id 'cpp'
	id 'cppunit-test-suite'
	id 'windows-resources'
	id 'windows-messages'
}


repositories {
	mavenCentral()
}

/*
dependencies {
	testCompile group: 'org.jvnet.hudson.plugins', name: 'cppunit', version: '1.10'
}
*/

File appendDebugSuffix(File binaryFile) {
	String name = binaryFile.getName()
	File parent = binaryFile.getParentFile()
	int extensionSeparatorIndex = name.lastIndexOf('.')
	if (extensionSeparatorIndex == -1) {
		return new File(parent, name + "d")
	}
	return new File(parent, name.substring(0, extensionSeparatorIndex) + "d" + name.substring(extensionSeparatorIndex))
}

File prefixByPoco(File binaryFile) {
	String name = binaryFile.getName()
	String prefix = ''
	if (name.startsWith('lib')) {
		prefix = 'lib'
		name = name.substring(3)
	}
	File parent = binaryFile.getParentFile()
	return new File(parent, prefix + "Poco" + name);
}
File toLocalBin(File binaryFile, Platform platform) {
	String name = binaryFile.getName()
	File parent = new File("bin")
	String target
	if (platform.architecture.name == 'x86') {
		target = 'bin'
	} else
	if (platform.architecture.name == 'x86-64') {
		target = 'bin64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	return new File(parent, name);
}
File toBin(File sharedFile, Platform platform) {
	String name = sharedFile.getName()
	String target
	if (platform.architecture.name == 'x86') {
		target = 'bin'
	} else
	if (platform.architecture.name == 'x86-64') {
		target = 'bin64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	File parent = new File(rootDir, target)
	return new File(parent, name);
}
File toLib(File linkFile, Platform platform) {
	// On macOS, it creates a dylib file which is the shared and import library
	if (platform.operatingSystem.macOsX) {
		return toBin(linkFile, platform)
	}

	String name = linkFile.getName()
	String target
	if (platform.architecture.name == 'x86') {
		target = 'lib'
	} else
	if (platform.architecture.name == 'x86-64') {
		target = 'lib64'
	} else {
		throw new GradleException("Unknown architecture: " + platform.architecture.name)
	}
	File parent = new File(rootDir, target )
	return new File(parent, name);
}
File toStatic(File staticFile) {
	String name = staticFile.getName()
	File parent = new File(rootDir, "static")
	return new File(parent, name);
}

task pocoDoc(type: Exec) {
//  environment PATH "$rootDir\bin;$PATH"
  executable "PocoDoc/bin/PocoDoc.exe"
  args "/config=PocoDoc/cfg/mkdoc-poco.xml"
  args "/config=stage/docbuild/PocoDoc.ini"
}
pocoDoc.dependsOn ':PocoDoc::assemble'

task zipDoc(type: Zip) {
   from 'releases/poco-2.0.0-all-doc/'
   include '*'
   include '*/*'
   archiveName 'poco-2.0.0-all-doc.zip'
   destinationDir(file('releases'))
}
zipDoc.dependsOn pocoDoc

def os = org.gradle.internal.os.OperatingSystem.current()
task production {
}
production.dependsOn ':CppUnit:assemble'
production.dependsOn ':Foundation:assemble'
production.dependsOn ':XML:assemble'
production.dependsOn ':JSON:assemble'
production.dependsOn ':Util:assemble'
production.dependsOn ':Net:assemble'
production.dependsOn ':Crypto:assemble'
production.dependsOn ':NetSSL_OpenSSL:assemble'
production.dependsOn ':NetSSL_Win:assemble'
production.dependsOn ':Data:assemble'
if (os.windows) {
	production.dependsOn ':Data:ODBC:assemble'
	production.dependsOn ':Data:SQLite:assemble'
	production.dependsOn ':Data:MySQL:assemble'
	production.dependsOn ':Data:PostgreSQL:assemble'
}
production.dependsOn ':Zip:assemble'
production.dependsOn ':PageCompiler:assemble'
production.dependsOn ':PageCompiler:File2Page:assemble'
production.dependsOn ':PDF:assemble'
production.dependsOn ':MongoDB:assemble'
production.dependsOn ':Redis:assemble'
production.dependsOn ':ProGen:assemble'

task unittest {
}
unittest.dependsOn ':CppParser:testsuite:assemble'
unittest.dependsOn ':Foundation:testsuite:assemble'
unittest.dependsOn ':XML:testsuite:assemble'
unittest.dependsOn ':JSON:testsuite:assemble'
unittest.dependsOn ':Util:testsuite:assemble'
unittest.dependsOn ':Net:testsuite:assemble'
unittest.dependsOn ':Crypto:testsuite:assemble'
unittest.dependsOn ':NetSSL_OpenSSL:testsuite:assemble'
unittest.dependsOn ':NetSSL_Win:testsuite:assemble'
unittest.dependsOn ':Data:testsuite:assemble'
if (os.windows) {
	unittest.dependsOn ':Data:ODBC:testsuite:assemble'
	unittest.dependsOn ':Data:SQLite:testsuite:assemble'
	unittest.dependsOn ':Data:MySQL:testsuite:assemble'
	unittest.dependsOn ':Data:PostgreSQL:testsuite:assemble'
}
unittest.dependsOn ':Zip:testsuite:assemble'
unittest.dependsOn ':MongoDB:testsuite:assemble'
unittest.dependsOn ':Redis:testsuite:assemble'

allprojects {
	buildDir = new File("gradle")	
}
subprojects {
	apply plugin:	'c'
	apply plugin:	'cpp'
	apply plugin:	'cppunit-test-suite'
 	apply plugin:	'windows-resources'
	apply plugin:	'windows-messages'

	

	model {
		buildTypes {
			release
			debug
		}

/*
		toolChains {
			visualCpp(VisualCpp) {
				// Specify the installDir if Visual Studio cannot be located
				// installDir "C:/Apps/Microsoft Visual Studio 10.0"
			}
			gcc(Gcc) {
				// Uncomment to use a GCC install that is not in the PATH
				// path "/usr/bin/gcc"
			}
			clang(Clang)
		}
*/
		platforms {
			win32 {
				operatingSystem "windows"
				architecture 'x86'
			}
			win64 {
				operatingSystem "windows"
				architecture 'x64'
			}
			linux32 {
				operatingSystem "linux"
				architecture 'x86'
			}
			linux64 {
				operatingSystem "linux"
				architecture 'x64'
			}
			macos {
				operatingSystem "macosx"
				architecture 'x64'
			}
		}

		flavors {
			bundled
//			unbundled
		}
		repositories {
			libs(PrebuiltLibraries) {
				WS2_32 {
					headers.srcDir 'C:/Program Files (x86)/Windows Kits/10/Include/10.0.15063.0/um'
					binaries.withType(StaticLibraryBinary) {
						if (targetPlatform.operatingSystem.windows) {
							staticLibraryFile = file('C:/Program Files (x86)/Windows Kits/10/Lib/10.0.15063.0/um/x86/WS2_32.lib')
						}
					}
				}
				def opensslHome = new File(rootDir, "openssl")
				def opensslBrewHome = new File('/usr/local/opt/openssl')
				crypto {
					headers.srcDir "$opensslHome/include"

					binaries.withType(StaticLibraryBinary) {
						def libName = "foobar"
						if (buildType == buildTypes.debug) {
							if (targetPlatform == 'win32') {
								libName = 'libeay32MTd.lib'
								staticLibraryFile = file("$opensslHome/win32/lib/debug/$libName")
							} else if (targetPlatform == 'win64') {
								libName = 'libeay64MTd.lib'
								staticLibraryFile = file("$opensslHome/win64/lib/debug/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								libName = 'libcrypto.a'
								staticLibraryFile = file("$opensslBrewHome/lib/$libName")
							}
						} else
						if (buildType == buildTypes.release) {
							if (targetPlatform == 'win32') {
								libName = 'libeay32MT.lib'
								staticLibraryFile = file("$opensslHome/win32/lib/release/$libName")
							} else if (targetPlatform == 'win64') {
								libName = 'libeay64MT.lib'
								staticLibraryFile = file("$opensslHome/win64/lib/release/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								libName = 'libcrypto.a'
								staticLibraryFile = file("$opensslBrewHome/lib/$libName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
					binaries.withType(SharedLibraryBinary) {
						def dllName
						def linkName
						if (buildType == buildTypes.debug) {
							if (targetPlatform == 'win32') {
								dllName = 'libeay32d.dll'
								linkName = 'libeay32d.lib'
								sharedLibraryFile	 = file("$opensslHome/win32/bin/debug/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win32/bin/debug/$linkName")
							} else if (targetPlatform == 'win64') {
								dllName = 'libeay64d.dll'
								linkName = 'libeay64d.lib'
								sharedLibraryFile	 = file("$opensslHome/win64/bin/debug/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win64/bin/debug/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								dllName = 'libcrypto.dylib'
								linkName = 'libcrypto.dylib'
								sharedLibraryFile	 = file("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = file("$opensslBrewHome/lib/$linkName")
							}
						} else
						if (buildType == buildTypes.release) {
							if (targetPlatform == 'win32') {
								dllName = 'libeay32.dll'
								linkName = 'libeay32.lib'
								sharedLibraryFile	 = file("$opensslHome/win32/bin/release/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win32/bin/release/$linkName")
							} else if (targetPlatform == 'win64') {
								dllName = 'libeay64.dll'
								linkName = 'libeay64.lib'
								sharedLibraryFile	 = file("$opensslHome/win64/bin/release/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win64/bin/release/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								dllName = 'libcrypto.dylib'
								linkName = 'libcrypto.dylib'
								sharedLibraryFile	 = file("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = file("$opensslBrewHome/lib/$linkName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
				}
				ssl {
					headers.srcDir "$opensslHome/include"

					binaries.withType(StaticLibraryBinary) {
						def libName
						if (buildType == buildTypes.debug) {
							if (targetPlatform == 'win32') {
								libName = 'ssleay32MTd.lib'
								staticLibraryFile = file("$opensslHome/win32/lib/debug/$libName")
							} else if (targetPlatform == 'win64') {
								libName = 'ssleay64MTd.lib'
								staticLibraryFile = file("$opensslHome/win64/lib/debug/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								libName = 'libssl.a'
								staticLibraryFile = file("$opensslBrewHome/lib/$libName")
							}
						} else
						if (buildType == buildTypes.release) {
							if (targetPlatform == 'win32') {
								libName = 'ssleay32MT.lib'
								staticLibraryFile = file("$opensslHome/win32/lib/release/$libName")
							} else if (targetPlatform == 'win64') {
								libName = 'ssleay64MT.lib'
								staticLibraryFile = file("$opensslHome/win64/lib/release/$libName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								libName = 'libssl.a'
								staticLibraryFile = file("$opensslBrewHome/lib/$libName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
					binaries.withType(SharedLibraryBinary) {
						def dllName
						def linkName
						if (buildType == buildTypes.debug) {
							if (targetPlatform == 'win32') {
								dllName = 'ssleay32d.dll'
								linkName = 'ssleay32d.lib'
								sharedLibraryFile	 = file("$opensslHome/win32/bin/debug/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win32/bin/debug/$linkName")
							} else if (targetPlatform == 'win64') {
								dllName = 'ssleay64d.dll'
								linkName = 'ssleay64d.lib'
								sharedLibraryFile	 = file("$opensslHome/win64/bin/debug/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win64/bin/debug/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								dllName = 'libssl.dylib'
								linkName = 'libssl.dylib'
								sharedLibraryFile	 = file("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = file("$opensslBrewHome/lib/$linkName")
							}
						} else if (buildType == buildTypes.release) {
							if (targetPlatform == 'win32') {
								dllName = 'ssleay32.dll'
								linkName = 'ssleay32.lib'
								sharedLibraryFile	 = file("$opensslHome/win32/bin/release/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win32/bin/release/$linkName")
							} else if (targetPlatform == 'win64') {
								dllName = 'ssleay64.dll'
								linkName = 'ssleay64.lib'
								sharedLibraryFile	 = file("$opensslHome/win64/bin/release/$dllName")
								sharedLibraryLinkFile = file("$opensslHome/win64/bin/release/$linkName")
							} else if (targetPlatform.operatingSystem.macOsX) {
								dllName = 'libssl.dylib'
								linkName = 'libssl.dylib'
								sharedLibraryFile	 = file("$opensslBrewHome/lib/$dllName")
								sharedLibraryLinkFile = file("$opensslBrewHome/lib/$linkName")
							}
						} else {
							throw new GradleException("Unknown buildType" + buildType)
						}
					}
				}
			}
		}
		components {
			withType(NativeComponentSpec) {
			targetPlatform "win32"
			targetPlatform "win64"
			targetPlatform "linux32"
			targetPlatform "linux64"
			targetPlatform "macos"
				binaries.withType(NativeTestSuiteBinarySpec) {
					if (buildType == buildTypes.debug) {
						if (it instanceof NativeExecutableBinarySpec) {
							executable.file = toLocalBin(appendDebugSuffix(executable.file), targetPlatform)
						}
					} else
					if (buildType == buildTypes.release) {
						if (it instanceof NativeExecutableBinarySpec) {
							executable.file = toLocalBin(executable.file, targetPlatform)
						} 
					}
				}
				binaries.withType(NativeBinarySpec) {

					if (toolChain in Clang) {
						cppCompiler.args "-std=c++11"
					}
					if (buildType == buildTypes.debug) {
						if (it instanceof SharedLibraryBinarySpec) {
							sharedLibraryFile	 = toBin(prefixByPoco(appendDebugSuffix(sharedLibraryFile)), targetPlatform)
							sharedLibraryLinkFile = toLib(prefixByPoco(appendDebugSuffix(sharedLibraryLinkFile)), targetPlatform)

							if (targetPlatform.operatingSystem.windows) {
								// WINDOWS ONLY
								linker.args "/implib:${sharedLibraryLinkFile}"  // For MSVC only
								// use the following for MinGW
								// linker.args "-Wl,--out-implib,${sharedLibraryLinkFile}"
								// This next part is simply to ensure the directory is created as the compiler (tested on MSVC only) won't create it
								def binary = it  // Simply to expose the binary in the `doFirst`
								tasks.withType(LinkSharedLibrary) {
									doFirst {
										binary.sharedLibraryLinkFile.parentFile.mkdirs()
									}
								}
							}
						} else
						if (it instanceof StaticLibraryBinarySpec) {
							staticLibraryFile = toStatic(prefixByPoco(appendDebugSuffix(staticLibraryFile)))
						} else
						if (it instanceof NativeExecutableBinarySpec) {
//							executable.file = toBin(appendDebugSuffix(executable.file), targetPlatform)
						} else {
							throw new GradleException("Unknown native library binary")
						}
					} else
					if (buildType == buildTypes.release) {
						if (it instanceof SharedLibraryBinarySpec) {
							sharedLibraryFile = toBin(prefixByPoco(sharedLibraryFile), targetPlatform)
							sharedLibraryLinkFile = toLib(prefixByPoco(sharedLibraryLinkFile), targetPlatform)

							if (targetPlatform.operatingSystem.windows) {
								// WINDOWS ONLY
								linker.args "/implib:${sharedLibraryLinkFile}"  // For MSVC only
								// use the following for MinGW
								// linker.args "-Wl,--out-implib,${sharedLibraryLinkFile}"
								// This next part is simply to ensure the directory is created as the compiler (tested on MSVC only) won't create it
								def binary = it  // Simply to expose the binary in the `doFirst`
								tasks.withType(LinkSharedLibrary) {
									doFirst {
										binary.sharedLibraryLinkFile.parentFile.mkdirs()
									}
								}
							}
						} else
						if (it instanceof StaticLibraryBinarySpec) {
							staticLibraryFile = toStatic(prefixByPoco(staticLibraryFile))
						} else
						if (it instanceof NativeExecutableBinarySpec) {
//							executable.file = toBin(executable.file, targetPlatform)
						} else {
							throw new GradleException("Unknown native library binary")
						} 
					} else {
						throw new GradleException("Unknown buildType" + buildType)
					}
				}
			}
		}


		binaries {
			all {
				if (flavor != flavors.bundled) {
					cCompiler.define 'POCO_UNBUNDLED'
					cppCompiler.define 'POCO_UNBUNDLED'
				}
				if (buildType == buildTypes.debug) {
					cCompiler.define '_DEBUG'
					cppCompiler.define '_DEBUG'
				} else 
				if (buildType == buildTypes.release) {
					cCompiler.define 'NDEBUG'
					cppCompiler.define 'NDEBUG'
				} else {
					throw new GradleException("Unknown buildType" + buildType)
				}
			
				if (toolChain in VisualCpp) {
					if (targetPlatform == platforms.win64) {
						linker.args '/MACHINE:X64'
					}
					if (buildType == buildTypes.debug) {
						cCompiler.args '/Zi'
						cppCompiler.args '/Zi'
						linker.args '/DEBUG'
					}
					cCompiler.args '/FS'
					cCompiler.args '/Zc:wchar_t'
					cCompiler.args '/Zc:inline'
					cCompiler.args '/Zc:forScope'
					cCompiler.args '/GR'
					cCompiler.args '/GF'
					cCompiler.args '/EHsc'
					cCompiler.args '/bigobj'
					cCompiler.define 'WIN32'
					cCompiler.define '_WIN32'
					cCompiler.define '_WINDOWS'
					cCompiler.define '_MBCS'

					cppCompiler.args '/FS'
					cppCompiler.args '/Zc:wchar_t'
					cppCompiler.args '/Zc:inline'
					cppCompiler.args '/Zc:forScope'
					cppCompiler.args '/GR'
					cppCompiler.args '/GF'
					cppCompiler.args '/EHsc'
					cppCompiler.args '/bigobj'
					cppCompiler.define 'WIN32'
					cppCompiler.define '_WIN32'
					cppCompiler.define '_WINDOWS'
					cppCompiler.define '_MBCS'
				
					linker.args 'kernel32.lib'
					linker.args 'user32.lib'
					linker.args 'gdi32.lib'
					linker.args 'comdlg32.lib'
					linker.args 'advapi32.lib'
					linker.args 'shell32.lib'
					linker.args 'ole32.lib'
					linker.args 'oleaut32.lib'
					linker.args 'uuid.lib'
				
					if (buildType == buildTypes.debug) {
						cCompiler.args "/MDd"
						cppCompiler.args "/MDd"
					} else 
					if (buildType == buildTypes.release) {
						cCompiler.args "/MD"
						cppCompiler.args "/MD"
					} else {
						throw new GradleException("Unknown buildType" + buildType)
					}
					linker.args '/SUBSYSTEM:CONSOLE'
				}
			}
			withType(SharedLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define   '_USRDLL'
					cCompiler.define   '_WINDLL'
					cppCompiler.define '_USRDLL'
					cppCompiler.define '_WINDLL'
				}
			}
			withType(StaticLibraryBinarySpec) {
				if (toolChain in VisualCpp) {
					cCompiler.define   '_LIB'
					cppCompiler.define '_LIB'
					cCompiler.define   'POCO_STATIC'
					cppCompiler.define 'POCO_STATIC'
				}
			}
			withType(NativeExecutableSpec) {
				if (toolChain in VisualCpp) {
					
				}
			}
		}
	}
}


