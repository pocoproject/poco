//
// Array.h
//
// $Id$
//
// Library: JSON
// Package: JSON
// Module:  Array
//
// Definition of the Array class.
//
// Copyright (c) 2012, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#ifndef JSON_Array_INCLUDED
#define JSON_Array_INCLUDED


#include <vector>
#include <sstream>

#include "Poco/JSON/JSON.h"
#include "Poco/SharedPtr.h"
#include "Poco/DynamicAny.h"

namespace Poco
{
namespace JSON
{

class Object;


class JSON_API Array
{
public:

	typedef std::vector<DynamicAny> ValueVector;


	typedef SharedPtr<Array> Ptr;


	Array();
		/// Default constructor


	Array(const Array& copy);
		/// Copy Constructor


	virtual ~Array();
		/// Destructor


	ValueVector::const_iterator begin() const;
		/// Returns iterator


	ValueVector::const_iterator end() const;
		/// Returns iterator


	DynamicAny get(unsigned int index) const;
		/// Retrieves an element. Will return an empty value
		/// when the element doesn't exist.


	Array::Ptr getArray(unsigned int index) const;
		/// Retrieves an array. When the element is not
		/// an array or doesn't exist, an empty SharedPtr is returned.

	template<typename T>
	T getElement(unsigned int index) const
		/// Retrieves an element and tries to convert it to the
		/// template type. The convert<T> method of
		/// Dynamic is called which can also throw
		/// exceptions for invalid values.
		/// Note: This will not work for an array or an object.
	{
		DynamicAny value = get(index);
		return value.convert<T>();
	}


	SharedPtr<Object> getObject(unsigned int index) const;
		/// Retrieves an object. When the element is not
		/// an object or doesn't exist, an empty SharedPtr is returned.

	unsigned int size() const;
		/// Returns the size of the array


	bool isArray(unsigned int index) const;
		/// Returns true when the element is an array


	bool isNull(unsigned int index) const;
		/// Returns true when the element is null or
		/// when the element doesn't exist.


	bool isObject(unsigned int index) const;
		/// Returns true when the element is an object


	template<typename T>
	T optElement(unsigned int index, const T& def) const
		/// Returns the element at the given index. When
		/// the element is null, doesn't exist or can't
		/// be converted to the given type, the default
		/// value will be returned
	{
		T value = def;
		if ( index < _values.size() )
		{
			try
			{
				value = _values[index].convert<T>();
			}
			catch(...)
			{
				// Default value is returned.
			}
		}
		return value;
	}


	void add(const DynamicAny& value)
		/// Add the given value to the array
	{
		_values.push_back(value);
	}


	void stringify(std::ostream& out, unsigned int indent) const;
		/// Prints the array to out. When indent is 0, the array
		/// will be printed on one line without indentation.


	void remove(unsigned int index);
		/// Removes the element on the given index.

private:

	ValueVector _values;
};


inline Array::ValueVector::const_iterator Array::begin() const
{
	return _values.begin();
}

inline Array::ValueVector::const_iterator Array::end() const

{
	return _values.end();
}

inline unsigned int Array::size() const
{
	return _values.size();
}

inline bool Array::isArray(unsigned int index) const
{
	DynamicAny value = get(index);
	return value.type() == typeid(Array::Ptr);
}

inline bool Array::isNull(unsigned int index) const
{
	if ( index < _values.size() )
	{
		DynamicAny value = _values[index];
		return value.isEmpty();
	}
	return true;
}


inline void Array::remove(unsigned int index)
{
	_values.erase(_values.begin() + index);
}

}} // Namespace Poco::JSON

namespace Poco
{

template <>
class DynamicAnyHolderImpl<JSON::Array::Ptr>: public DynamicAnyHolder
{
public:
	DynamicAnyHolderImpl(const JSON::Array::Ptr& val): _val(val)
	{
	}

	~DynamicAnyHolderImpl()
	{
	}

	const std::type_info& type() const
	{
		return typeid(JSON::Array::Ptr);
	}

	void convert(Int8&) const
	{
		throw BadCastException();
	}

	void convert(Int16&) const
	{
		throw BadCastException();
	}

	void convert(Int32&) const
	{
		throw BadCastException();
	}

	void convert(Int64&) const
	{
		throw BadCastException();
	}

	void convert(UInt8&) const
	{
		throw BadCastException();
	}

	void convert(UInt16&) const
	{
		throw BadCastException();
	}

	void convert(UInt32&) const
	{
		throw BadCastException();
	}

	void convert(UInt64&) const
	{
		throw BadCastException();
	}

	void convert(bool& value) const
	{
		value = !_val.isNull() && _val->size() > 0;
	}

	void convert(float&) const
	{
		throw BadCastException();
	}

	void convert(double&) const
	{
		throw BadCastException();
	}

	void convert(char&) const
	{
		throw BadCastException();
	}

	void convert(std::string& s) const
	{
		std::ostringstream oss;
		_val->stringify(oss, 2);
		s = oss.str();
	}

	void convert(DateTime& val) const
	{
		throw BadCastException();
	}

	void convert(LocalDateTime& ldt) const
	{
		throw BadCastException();
	}

	void convert(Timestamp& ts) const
	{
		throw BadCastException();
	}

	DynamicAnyHolder* clone() const
	{
		return new DynamicAnyHolderImpl(_val);
	}

	const JSON::Array::Ptr& value() const
	{
		return _val;
	}

	bool isArray() const
	{
		return false;
	}

	bool isInteger() const
	{
		return false;
	}

	bool isSigned() const
	{
		return false;
	}

	bool isNumeric() const
	{
		return false;
	}

	bool isString() const
	{
		return false;
	}

private:
	JSON::Array::Ptr _val;
};

} // Namespace Poco


#endif // JSON_Array_INCLUDED
